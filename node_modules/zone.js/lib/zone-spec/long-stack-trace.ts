/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
<<<<<<< HEAD
/**
 * @fileoverview
 * @suppress {globalThis}
 */

const NEWLINE = '\n';
const IGNORE_FRAMES: {[k: string]: true} = {};
const creationTrace = '__creationTrace__';
const ERROR_TAG = 'STACKTRACE TRACKING';
const SEP_TAG = '__SEP_TAG__';
let sepTemplate: string = SEP_TAG + '@[native]';
=======

const NEWLINE = '\n';
const SEP = '  -------------  ';
const IGNORE_FRAMES = [];
const creationTrace = '__creationTrace__';
>>>>>>> origin/foodtriangle_node

class LongStackTrace {
  error: Error = getStacktrace();
  timestamp: Date = new Date();
}

function getStacktraceWithUncaughtError(): Error {
<<<<<<< HEAD
  return new Error(ERROR_TAG);
=======
  return new Error('STACKTRACE TRACKING');
>>>>>>> origin/foodtriangle_node
}

function getStacktraceWithCaughtError(): Error {
  try {
    throw getStacktraceWithUncaughtError();
<<<<<<< HEAD
  } catch (err) {
    return err;
=======
  } catch (e) {
    return e;
>>>>>>> origin/foodtriangle_node
  }
}

// Some implementations of exception handling don't create a stack trace if the exception
// isn't thrown, however it's faster not to actually throw the exception.
const error = getStacktraceWithUncaughtError();
<<<<<<< HEAD
const caughtError = getStacktraceWithCaughtError();
const getStacktrace = error.stack ?
    getStacktraceWithUncaughtError :
    (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);
=======
const coughtError = getStacktraceWithCaughtError();
const getStacktrace = error.stack ?
    getStacktraceWithUncaughtError :
    (coughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);
>>>>>>> origin/foodtriangle_node

function getFrames(error: Error): string[] {
  return error.stack ? error.stack.split(NEWLINE) : [];
}

function addErrorStack(lines: string[], error: Error): void {
  let trace: string[] = getFrames(error);
  for (let i = 0; i < trace.length; i++) {
    const frame = trace[i];
    // Filter out the Frames which are part of stack capturing.
<<<<<<< HEAD
    if (!IGNORE_FRAMES.hasOwnProperty(frame)) {
=======
    if (!(i < IGNORE_FRAMES.length && IGNORE_FRAMES[i] === frame)) {
>>>>>>> origin/foodtriangle_node
      lines.push(trace[i]);
    }
  }
}

function renderLongStackTrace(frames: LongStackTrace[], stack: string): string {
<<<<<<< HEAD
  const longTrace: string[] = [stack.trim()];
=======
  const longTrace: string[] = [stack];
>>>>>>> origin/foodtriangle_node

  if (frames) {
    let timestamp = new Date().getTime();
    for (let i = 0; i < frames.length; i++) {
      const traceFrames: LongStackTrace = frames[i];
      const lastTime = traceFrames.timestamp;
<<<<<<< HEAD
      let separator =
          `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;
      separator = separator.replace(/[^\w\d]/g, '_');
      longTrace.push(sepTemplate.replace(SEP_TAG, separator));
=======
      longTrace.push(
          `${SEP} Elapsed: ${timestamp - lastTime.getTime()} ms; At: ${lastTime} ${SEP}`);
>>>>>>> origin/foodtriangle_node
      addErrorStack(longTrace, traceFrames.error);

      timestamp = lastTime.getTime();
    }
  }

  return longTrace.join(NEWLINE);
}

<<<<<<< HEAD
(Zone as any)['longStackTraceZoneSpec'] = <ZoneSpec>{
  name: 'long-stack-trace',
  longStackTraceLimit: 10,  // Max number of task to keep the stack trace for.
  // add a getLongStackTrace method in spec to
  // handle handled reject promise error.
  getLongStackTrace: function(error: Error): string {
    if (!error) {
      return undefined;
    }
    const task = (error as any)[(Zone as any).__symbol__('currentTask')];
    const trace = task && task.data && task.data[creationTrace];
    if (!trace) {
      return error.stack;
    }
    return renderLongStackTrace(trace, error.stack);
  },
=======
Zone['longStackTraceZoneSpec'] = <ZoneSpec>{
  name: 'long-stack-trace',
  longStackTraceLimit: 10,  // Max number of task to keep the stack trace for.
>>>>>>> origin/foodtriangle_node

  onScheduleTask: function(
      parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, task: Task): any {
    const currentTask = Zone.currentTask;
<<<<<<< HEAD
    let trace = currentTask && currentTask.data && (currentTask.data as any)[creationTrace] || [];
=======
    let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];
>>>>>>> origin/foodtriangle_node
    trace = [new LongStackTrace()].concat(trace);
    if (trace.length > this.longStackTraceLimit) {
      trace.length = this.longStackTraceLimit;
    }
    if (!task.data) task.data = {};
<<<<<<< HEAD
    (task.data as any)[creationTrace] = trace;
=======
    task.data[creationTrace] = trace;
>>>>>>> origin/foodtriangle_node
    return parentZoneDelegate.scheduleTask(targetZone, task);
  },

  onHandleError: function(
<<<<<<< HEAD
      parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, error: any): boolean {
    const parentTask = Zone.currentTask || error.task;
    if (error instanceof Error && parentTask) {
      const longStack =
          renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);
      try {
        error.stack = (error as any).longStack = longStack;
      } catch (err) {
=======
      parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, error: any): any {
    const parentTask = Zone.currentTask || error.task;
    if (error instanceof Error && parentTask) {
      var stackSetSucceded: string|boolean = null;
      try {
        let descriptor = Object.getOwnPropertyDescriptor(error, 'stack');
        if (descriptor && descriptor.configurable) {
          const delegateGet = descriptor.get;
          const value = descriptor.value;
          descriptor = {
            get: function() {
              return renderLongStackTrace(
                  parentTask.data && parentTask.data[creationTrace],
                  delegateGet ? delegateGet.apply(this) : value);
            }
          };
          Object.defineProperty(error, 'stack', descriptor);
          stackSetSucceded = true;
        }
      } catch (e) {
      }
      var longStack: string = stackSetSucceded ?
          null :
          renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);
      if (!stackSetSucceded) {
        try {
          stackSetSucceded = error.stack = longStack;
        } catch (e) {
        }
      }
      if (!stackSetSucceded) {
        try {
          stackSetSucceded = (error as any).longStack = longStack;
        } catch (e) {
        }
>>>>>>> origin/foodtriangle_node
      }
    }
    return parentZoneDelegate.handleError(targetZone, error);
  }
};

function captureStackTraces(stackTraces: string[][], count: number): void {
  if (count > 0) {
    stackTraces.push(getFrames((new LongStackTrace()).error));
    captureStackTraces(stackTraces, count - 1);
  }
}

function computeIgnoreFrames() {
  const frames: string[][] = [];
  captureStackTraces(frames, 2);
  const frames1 = frames[0];
  const frames2 = frames[1];
  for (let i = 0; i < frames1.length; i++) {
    const frame1 = frames1[i];
<<<<<<< HEAD
    if (frame1.indexOf(ERROR_TAG) == -1) {
      let match = frame1.match(/^\s*at\s+/);
      if (match) {
        sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';
        break;
      }
    }
  }

  for (let i = 0; i < frames1.length; i++) {
    const frame1 = frames1[i];
    const frame2 = frames2[i];
    if (frame1 === frame2) {
      IGNORE_FRAMES[frame1] = true;
=======
    const frame2 = frames2[i];
    if (frame1 === frame2) {
      IGNORE_FRAMES.push(frame1);
>>>>>>> origin/foodtriangle_node
    } else {
      break;
    }
  }
}
computeIgnoreFrames();
