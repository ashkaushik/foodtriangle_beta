/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

<<<<<<< HEAD
import {patchTimer} from '../common/timers';
import {findEventTask, patchClass, patchEventTargetMethods, patchMethod, patchPrototype, zoneSymbol} from '../common/utils';
=======
import '../zone';

import {patchTimer} from '../common/timers';
import {patchClass, patchMethod, patchPrototype, zoneSymbol} from '../common/utils';
>>>>>>> origin/foodtriangle_node

import {propertyPatch} from './define-property';
import {eventTargetPatch} from './event-target';
import {propertyDescriptorPatch} from './property-descriptor';
import {registerElementPatch} from './register-element';

const set = 'set';
const clear = 'clear';
const blockingMethods = ['alert', 'prompt', 'confirm'];
<<<<<<< HEAD
const _global: any =
    typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global;
=======
const _global = typeof window === 'object' && window || typeof self === 'object' && self || global;
>>>>>>> origin/foodtriangle_node

patchTimer(_global, set, clear, 'Timeout');
patchTimer(_global, set, clear, 'Interval');
patchTimer(_global, set, clear, 'Immediate');
patchTimer(_global, 'request', 'cancel', 'AnimationFrame');
patchTimer(_global, 'mozRequest', 'mozCancel', 'AnimationFrame');
patchTimer(_global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');

<<<<<<< HEAD
for (let i = 0; i < blockingMethods.length; i++) {
  const name = blockingMethods[i];
=======
for (var i = 0; i < blockingMethods.length; i++) {
  var name = blockingMethods[i];
>>>>>>> origin/foodtriangle_node
  patchMethod(_global, name, (delegate, symbol, name) => {
    return function(s: any, args: any[]) {
      return Zone.current.run(delegate, _global, args, name);
    };
  });
}

eventTargetPatch(_global);
<<<<<<< HEAD
// patch XMLHttpRequestEventTarget's addEventListener/removeEventListener
const XMLHttpRequestEventTarget = (_global as any)['XMLHttpRequestEventTarget'];
if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
  patchEventTargetMethods(XMLHttpRequestEventTarget.prototype);
}
=======
>>>>>>> origin/foodtriangle_node
propertyDescriptorPatch(_global);
patchClass('MutationObserver');
patchClass('WebKitMutationObserver');
patchClass('FileReader');
propertyPatch();
registerElementPatch(_global);

// Treat XMLHTTPRequest as a macrotask.
patchXHR(_global);

const XHR_TASK = zoneSymbol('xhrTask');
const XHR_SYNC = zoneSymbol('xhrSync');
<<<<<<< HEAD
const XHR_LISTENER = zoneSymbol('xhrListener');
const XHR_SCHEDULED = zoneSymbol('xhrScheduled');
=======
>>>>>>> origin/foodtriangle_node

interface XHROptions extends TaskData {
  target: any;
  args: any[];
  aborted: boolean;
}

function patchXHR(window: any) {
  function findPendingTask(target: any) {
<<<<<<< HEAD
    const pendingTask: Task = target[XHR_TASK];
=======
    var pendingTask: Task = target[XHR_TASK];
>>>>>>> origin/foodtriangle_node
    return pendingTask;
  }

  function scheduleTask(task: Task) {
<<<<<<< HEAD
    (XMLHttpRequest as any)[XHR_SCHEDULED] = false;
    const data = <XHROptions>task.data;
    // remove existing event listener
    const listener = data.target[XHR_LISTENER];
    if (listener) {
      data.target.removeEventListener('readystatechange', listener);
    }
    const newListener = data.target[XHR_LISTENER] = () => {
      if (data.target.readyState === data.target.DONE) {
        // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with
        // readyState=4 multiple times, so we need to check task state here
        if (!data.aborted && (XMLHttpRequest as any)[XHR_SCHEDULED] && task.state === 'scheduled') {
          task.invoke();
        }
      }
    };
    data.target.addEventListener('readystatechange', newListener);

    const storedTask: Task = data.target[XHR_TASK];
=======
    var data = <XHROptions>task.data;
    data.target.addEventListener('readystatechange', () => {
      if (data.target.readyState === data.target.DONE) {
        if (!data.aborted) {
          task.invoke();
        }
      }
    });
    var storedTask: Task = data.target[XHR_TASK];
>>>>>>> origin/foodtriangle_node
    if (!storedTask) {
      data.target[XHR_TASK] = task;
    }
    sendNative.apply(data.target, data.args);
<<<<<<< HEAD
    (XMLHttpRequest as any)[XHR_SCHEDULED] = true;
=======
>>>>>>> origin/foodtriangle_node
    return task;
  }

  function placeholderCallback() {}

  function clearTask(task: Task) {
<<<<<<< HEAD
    const data = <XHROptions>task.data;
=======
    var data = <XHROptions>task.data;
>>>>>>> origin/foodtriangle_node
    // Note - ideally, we would call data.target.removeEventListener here, but it's too late
    // to prevent it from firing. So instead, we store info for the event listener.
    data.aborted = true;
    return abortNative.apply(data.target, data.args);
  }

<<<<<<< HEAD
  const openNative: Function =
=======
  var openNative =
>>>>>>> origin/foodtriangle_node
      patchMethod(window.XMLHttpRequest.prototype, 'open', () => function(self: any, args: any[]) {
        self[XHR_SYNC] = args[2] == false;
        return openNative.apply(self, args);
      });

<<<<<<< HEAD
  const sendNative: Function =
      patchMethod(window.XMLHttpRequest.prototype, 'send', () => function(self: any, args: any[]) {
        const zone = Zone.current;
=======
  var sendNative =
      patchMethod(window.XMLHttpRequest.prototype, 'send', () => function(self: any, args: any[]) {
        var zone = Zone.current;
>>>>>>> origin/foodtriangle_node
        if (self[XHR_SYNC]) {
          // if the XHR is sync there is no task to schedule, just execute the code.
          return sendNative.apply(self, args);
        } else {
<<<<<<< HEAD
          const options: XHROptions =
=======
          var options: XHROptions =
>>>>>>> origin/foodtriangle_node
              {target: self, isPeriodic: false, delay: null, args: args, aborted: false};
          return zone.scheduleMacroTask(
              'XMLHttpRequest.send', placeholderCallback, options, scheduleTask, clearTask);
        }
      });

<<<<<<< HEAD
  const abortNative = patchMethod(
      window.XMLHttpRequest.prototype, 'abort',
      (delegate: Function) => function(self: any, args: any[]) {
        const task: Task = findPendingTask(self);
        if (task && typeof task.type == 'string') {
          // If the XHR has already completed, do nothing.
          // If the XHR has already been aborted, do nothing.
          // Fix #569, call abort multiple times before done will cause
          // macroTask task count be negative number
          if (task.cancelFn == null || (task.data && (<XHROptions>task.data).aborted)) {
=======
  var abortNative = patchMethod(
      window.XMLHttpRequest.prototype, 'abort',
      (delegate: Function) => function(self: any, args: any[]) {
        var task: Task = findPendingTask(self);
        if (task && typeof task.type == 'string') {
          // If the XHR has already completed, do nothing.
          if (task.cancelFn == null) {
>>>>>>> origin/foodtriangle_node
            return;
          }
          task.zone.cancelTask(task);
        }
        // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no task
        // to cancel. Do nothing.
      });
}

/// GEO_LOCATION
if (_global['navigator'] && _global['navigator'].geolocation) {
  patchPrototype(_global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);
}
<<<<<<< HEAD

// handle unhandled promise rejection
function findPromiseRejectionHandler(evtName: string) {
  return function(e: any) {
    const eventTasks = findEventTask(_global, evtName);
    eventTasks.forEach(eventTask => {
      // windows has added unhandledrejection event listener
      // trigger the event listener
      const PromiseRejectionEvent = _global['PromiseRejectionEvent'];
      if (PromiseRejectionEvent) {
        const evt = new PromiseRejectionEvent(evtName, {promise: e.promise, reason: e.rejection});
        eventTask.invoke(evt);
      }
    });
  };
}

if (_global['PromiseRejectionEvent']) {
  (Zone as any)[zoneSymbol('unhandledPromiseRejectionHandler')] =
      findPromiseRejectionHandler('unhandledrejection');

  (Zone as any)[zoneSymbol('rejectionHandledHandler')] =
      findPromiseRejectionHandler('rejectionhandled');
}
=======
>>>>>>> origin/foodtriangle_node
