/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

import {patchMethod} from './utils';

interface TimerOptions extends TaskData {
  handleId: number;
  args: any[];
}

export function patchTimer(window: any, setName: string, cancelName: string, nameSuffix: string) {
<<<<<<< HEAD
  let setNative: Function = null;
  let clearNative: Function = null;
=======
  var setNative = null;
  var clearNative = null;
>>>>>>> origin/foodtriangle_node
  setName += nameSuffix;
  cancelName += nameSuffix;

  const tasksByHandleId: {[id: number]: Task} = {};

  function scheduleTask(task: Task) {
    const data = <TimerOptions>task.data;
<<<<<<< HEAD
    function timer() {
      try {
        task.invoke.apply(this, arguments);
      } finally {
        delete tasksByHandleId[data.handleId];
      }
    };
    data.args[0] = timer;
=======
    data.args[0] = function() {
      task.invoke.apply(this, arguments);
      delete tasksByHandleId[data.handleId];
    };
>>>>>>> origin/foodtriangle_node
    data.handleId = setNative.apply(window, data.args);
    tasksByHandleId[data.handleId] = task;
    return task;
  }

  function clearTask(task: Task) {
    delete tasksByHandleId[(<TimerOptions>task.data).handleId];
    return clearNative((<TimerOptions>task.data).handleId);
  }

  setNative =
      patchMethod(window, setName, (delegate: Function) => function(self: any, args: any[]) {
        if (typeof args[0] === 'function') {
<<<<<<< HEAD
          const zone = Zone.current;
          const options: TimerOptions = {
=======
          var zone = Zone.current;
          var options: TimerOptions = {
>>>>>>> origin/foodtriangle_node
            handleId: null,
            isPeriodic: nameSuffix === 'Interval',
            delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,
            args: args
          };
<<<<<<< HEAD
          const task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);
=======
          var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);
>>>>>>> origin/foodtriangle_node
          if (!task) {
            return task;
          }
          // Node.js must additionally support the ref and unref functions.
<<<<<<< HEAD
          const handle: any = (<TimerOptions>task.data).handleId;
          // check whether handle is null, because some polyfill or browser
          // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame
          if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' &&
              typeof handle.unref === 'function') {
=======
          var handle = (<TimerOptions>task.data).handleId;
          if ((<any>handle).ref && (<any>handle).unref) {
>>>>>>> origin/foodtriangle_node
            (<any>task).ref = (<any>handle).ref.bind(handle);
            (<any>task).unref = (<any>handle).unref.bind(handle);
          }
          return task;
        } else {
          // cause an error by calling it directly.
          return delegate.apply(window, args);
        }
      });

  clearNative =
      patchMethod(window, cancelName, (delegate: Function) => function(self: any, args: any[]) {
<<<<<<< HEAD
        const task: Task = typeof args[0] === 'number' ? tasksByHandleId[args[0]] : args[0];
        if (task && typeof task.type === 'string') {
          if (task.state !== 'notScheduled' &&
              (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
=======
        var task: Task = typeof args[0] === 'number' ? tasksByHandleId[args[0]] : args[0];
        if (task && typeof task.type === 'string') {
          if (task.cancelFn && task.data.isPeriodic || task.runCount === 0) {
>>>>>>> origin/foodtriangle_node
            // Do not cancel already canceled functions
            task.zone.cancelTask(task);
          }
        } else {
          // cause an error by calling it directly.
          delegate.apply(window, args);
        }
      });
}
