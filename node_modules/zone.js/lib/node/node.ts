/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

import '../zone';
import './events';
import './fs';

import {patchTimer} from '../common/timers';
<<<<<<< HEAD
import {findEventTask, patchMacroTask, patchMicroTask, zoneSymbol} from '../common/utils';
=======
>>>>>>> origin/foodtriangle_node

const set = 'set';
const clear = 'clear';
const _global = typeof window === 'object' && window || typeof self === 'object' && self || global;

// Timers
const timers = require('timers');
patchTimer(timers, set, clear, 'Timeout');
patchTimer(timers, set, clear, 'Interval');
patchTimer(timers, set, clear, 'Immediate');

const shouldPatchGlobalTimers = global.setTimeout !== timers.setTimeout;

if (shouldPatchGlobalTimers) {
  patchTimer(_global, set, clear, 'Timeout');
  patchTimer(_global, set, clear, 'Interval');
  patchTimer(_global, set, clear, 'Immediate');
}

<<<<<<< HEAD
// patch process related methods
patchProcess();
handleUnhandledPromiseRejection();

// Crypto
let crypto: any;
=======

// Crypto
let crypto;
>>>>>>> origin/foodtriangle_node
try {
  crypto = require('crypto');
} catch (err) {
}

<<<<<<< HEAD
// use the generic patchMacroTask to patch crypto
if (crypto) {
  const methodNames = ['randomBytes', 'pbkdf2'];
  methodNames.forEach(name => {
    patchMacroTask(crypto, name, (self: any, args: any[]) => {
      return {
        name: 'crypto.' + name,
        args: args,
        callbackIndex:
            (args.length > 0 && typeof args[args.length - 1] === 'function') ? args.length - 1 : -1,
        target: crypto
      };
    });
  });
}

function patchProcess() {
  // patch nextTick as microTask
  patchMicroTask(process, 'nextTick', (self: any, args: any[]) => {
    return {
      name: 'process.nextTick',
      args: args,
      callbackIndex: (args.length > 0 && typeof args[0] === 'function') ? 0 : -1,
      target: process
    };
  });
}

// handle unhandled promise rejection
function findProcessPromiseRejectionHandler(evtName: string) {
  return function(e: any) {
    const eventTasks = findEventTask(process, evtName);
    eventTasks.forEach(eventTask => {
      // process has added unhandledrejection event listener
      // trigger the event listener
      if (evtName === 'unhandledRejection') {
        eventTask.invoke(e.rejection, e.promise);
      } else if (evtName === 'rejectionHandled') {
        eventTask.invoke(e.promise);
      }
    });
  };
}

function handleUnhandledPromiseRejection() {
  (Zone as any)[zoneSymbol('unhandledPromiseRejectionHandler')] =
      findProcessPromiseRejectionHandler('unhandledRejection');

  (Zone as any)[zoneSymbol('rejectionHandledHandler')] =
      findProcessPromiseRejectionHandler('rejectionHandled');
=======
// TODO(gdi2290): implement a better way to patch these methods
if (crypto) {
  let nativeRandomBytes = crypto.randomBytes;
  crypto.randomBytes = function randomBytesZone(size: number, callback?: Function) {
    if (!callback) {
      return nativeRandomBytes(size);
    } else {
      let zone = Zone.current;
      var source = crypto.constructor.name + '.randomBytes';
      return nativeRandomBytes(size, zone.wrap(callback, source));
    }
  }.bind(crypto);

  let nativePbkdf2 = crypto.pbkdf2;
  crypto.pbkdf2 = function pbkdf2Zone(...args: any[]) {
    let fn = args[args.length - 1];
    if (typeof fn === 'function') {
      let zone = Zone.current;
      var source = crypto.constructor.name + '.pbkdf2';
      args[args.length - 1] = zone.wrap(fn, source);
      return nativePbkdf2(...args);
    } else {
      return nativePbkdf2(...args);
    }
  }.bind(crypto);
}

// HTTP Client
let httpClient;
try {
  httpClient = require('_http_client');
} catch (err) {
}

if (httpClient && httpClient.ClientRequest) {
  let ClientRequest = httpClient.ClientRequest.bind(httpClient);
  httpClient.ClientRequest = function(options: any, callback?: Function) {
    if (!callback) {
      return new ClientRequest(options);
    } else {
      let zone = Zone.current;
      return new ClientRequest(options, zone.wrap(callback, 'http.ClientRequest'));
    }
  };
>>>>>>> origin/foodtriangle_node
}
