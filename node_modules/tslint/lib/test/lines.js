<<<<<<< HEAD
=======
/*
 * Copyright 2016 Palantir Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
>>>>>>> origin/foodtriangle_node
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var utils_1 = require("./utils");
<<<<<<< HEAD
=======
// Use classes here instead of interfaces because we want runtime type data
>>>>>>> origin/foodtriangle_node
var Line = (function () {
    function Line() {
    }
    return Line;
}());
exports.Line = Line;
var CodeLine = (function (_super) {
    __extends(CodeLine, _super);
    function CodeLine(contents) {
<<<<<<< HEAD
        _super.call(this);
        this.contents = contents;
=======
        var _this = _super.call(this) || this;
        _this.contents = contents;
        return _this;
>>>>>>> origin/foodtriangle_node
    }
    return CodeLine;
}(Line));
exports.CodeLine = CodeLine;
var MessageSubstitutionLine = (function (_super) {
    __extends(MessageSubstitutionLine, _super);
    function MessageSubstitutionLine(key, message) {
<<<<<<< HEAD
        _super.call(this);
        this.key = key;
        this.message = message;
=======
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.message = message;
        return _this;
>>>>>>> origin/foodtriangle_node
    }
    return MessageSubstitutionLine;
}(Line));
exports.MessageSubstitutionLine = MessageSubstitutionLine;
var ErrorLine = (function (_super) {
    __extends(ErrorLine, _super);
    function ErrorLine(startCol) {
<<<<<<< HEAD
        _super.call(this);
        this.startCol = startCol;
=======
        var _this = _super.call(this) || this;
        _this.startCol = startCol;
        return _this;
>>>>>>> origin/foodtriangle_node
    }
    return ErrorLine;
}(Line));
exports.ErrorLine = ErrorLine;
var MultilineErrorLine = (function (_super) {
    __extends(MultilineErrorLine, _super);
    function MultilineErrorLine(startCol) {
<<<<<<< HEAD
        _super.call(this, startCol);
=======
        return _super.call(this, startCol) || this;
>>>>>>> origin/foodtriangle_node
    }
    return MultilineErrorLine;
}(ErrorLine));
exports.MultilineErrorLine = MultilineErrorLine;
var EndErrorLine = (function (_super) {
    __extends(EndErrorLine, _super);
    function EndErrorLine(startCol, endCol, message) {
<<<<<<< HEAD
        _super.call(this, startCol);
        this.endCol = endCol;
        this.message = message;
=======
        var _this = _super.call(this, startCol) || this;
        _this.endCol = endCol;
        _this.message = message;
        return _this;
>>>>>>> origin/foodtriangle_node
    }
    return EndErrorLine;
}(ErrorLine));
exports.EndErrorLine = EndErrorLine;
<<<<<<< HEAD
var multilineErrorRegex = /^\s*(~+|~nil)$/;
var endErrorRegex = /^\s*(~+|~nil)\s*\[(.+)\]\s*$/;
var messageSubstitutionRegex = /^\[([\w\-\_]+?)]: \s*(.+?)\s*$/;
exports.ZERO_LENGTH_ERROR = "~nil";
=======
// example matches (between the quotes): 
// "    ~~~~~~~~"
var multilineErrorRegex = /^\s*(~+|~nil)$/;
// "    ~~~~~~~~~   [some error message]"
var endErrorRegex = /^\s*(~+|~nil)\s*\[(.+)\]\s*$/;
// "[shortcut]: full messages goes here!!  "
var messageSubstitutionRegex = /^\[([\w\-\_]+?)]: \s*(.+?)\s*$/;
exports.ZERO_LENGTH_ERROR = "~nil";
/**
 * Maps a line of text from a .lint file to an appropriate Line object
 */
>>>>>>> origin/foodtriangle_node
function parseLine(text) {
    var multilineErrorMatch = text.match(multilineErrorRegex);
    if (multilineErrorMatch != null) {
        var startErrorCol = text.indexOf("~");
        return new MultilineErrorLine(startErrorCol);
    }
    var endErrorMatch = text.match(endErrorRegex);
    if (endErrorMatch != null) {
        var squiggles = endErrorMatch[1], message = endErrorMatch[2];
        var startErrorCol = text.indexOf("~");
        var zeroLengthError = (squiggles === exports.ZERO_LENGTH_ERROR);
        var endErrorCol = zeroLengthError ? startErrorCol : text.lastIndexOf("~") + 1;
        return new EndErrorLine(startErrorCol, endErrorCol, message);
    }
    var messageSubstitutionMatch = text.match(messageSubstitutionRegex);
    if (messageSubstitutionMatch != null) {
        var key = messageSubstitutionMatch[1], message = messageSubstitutionMatch[2];
        return new MessageSubstitutionLine(key, message);
    }
<<<<<<< HEAD
    return new CodeLine(text);
}
exports.parseLine = parseLine;
=======
    // line doesn't match any syntax for error markup, so it's a line of code to be linted
    return new CodeLine(text);
}
exports.parseLine = parseLine;
/**
 * Maps a Line object to a matching line of text that could be in a .lint file.
 * This is almost the inverse of parseLine.
 * If you ran `printLine(parseLine(someText), code)`, the whitespace in the result may be different than in someText
 * @param line - A Line object to convert to text
 * @param code - If line represents error markup, this is the line of code preceding the markup.
 *               Otherwise, this parameter is not required.
 */
>>>>>>> origin/foodtriangle_node
function printLine(line, code) {
    if (line instanceof ErrorLine) {
        if (code == null) {
            throw new Error("Must supply argument for code parameter when line is an ErrorLine");
        }
        var leadingSpaces = utils_1.replicateStr(" ", line.startCol);
        if (line instanceof MultilineErrorLine) {
<<<<<<< HEAD
=======
            // special case for when the line of code is simply a newline.
            // use "~nil" to indicate the error continues on that line
>>>>>>> origin/foodtriangle_node
            if (code.length === 0 && line.startCol === 0) {
                return exports.ZERO_LENGTH_ERROR;
            }
            var tildes = utils_1.replicateStr("~", code.length - leadingSpaces.length);
            return "" + leadingSpaces + tildes;
        }
        else if (line instanceof EndErrorLine) {
            var tildes = utils_1.replicateStr("~", line.endCol - line.startCol);
            var endSpaces = utils_1.replicateStr(" ", code.length - line.endCol);
            if (tildes.length === 0) {
                tildes = exports.ZERO_LENGTH_ERROR;
<<<<<<< HEAD
=======
                // because we add "~nil" we need four less spaces than normal at the end
                // always make sure we have at least one space though
>>>>>>> origin/foodtriangle_node
                endSpaces = endSpaces.substring(0, Math.max(endSpaces.length - 4, 1));
            }
            return "" + leadingSpaces + tildes + endSpaces + " [" + line.message + "]";
        }
    }
    else if (line instanceof MessageSubstitutionLine) {
        return "[" + line.key + "]: " + line.message;
    }
    else if (line instanceof CodeLine) {
        return line.contents;
    }
}
exports.printLine = printLine;
